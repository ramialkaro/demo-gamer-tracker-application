module.exports=function(serverDirectory,modules){
	var http=require("./httputils")(serverDirectory);
	var fs = require("fs");
	var rimraf = require("rimraf");
	var ncp = require("ncp").ncp;

	var wwwroot="wwwroot";
	var libDir=wwwroot+"/libs";
	return {
		copy(src,target){
			if (src.startsWith("bootstrap")) console.log("Bootstrap starting");
			fs.stat(src,function(err,stat){
				if (err) console.log("Error processing "+src,target);
				else {
					if (stat.isDirectory()) {
						ncp(src,target,function(err){
							if (err) console.log("Error with "+src);
						});
					}
					else fs.createReadStream(src).pipe(fs.createWriteStream(target));
				}
			});
		},

		nodeToWww(descr){
			for(var k in descr) 
				this.copy("node_modules/"+k,libDir+"/"+descr[k]);
		},

		safeCreate(dir){
			try{
				fs.mkdirSync(dir);
			}
			catch(e){
				console.log("Cannot create",dir);
			}
		},
		
		ensureDirs(dirs){
			dirs.forEach(dir => this.safeCreate(wwwroot+"/"+dir));
		},
		
		doConfig(){
			var self=this;
			self.safeCreate(wwwroot);
			self.safeCreate(libDir);
			modules.forEach(function(module){
				http.getJSON(module,function(conf,err){
					if (err) console.error("Error with "+module,err);
					else {
						if (conf.directories) self.ensureDirs(conf.directories);
						if (conf.libDir) self.safeCreate(libDir+"/"+conf.libdir);	
						for(var k in conf.downloads){
							http.downloadArray(k,conf.downloads[k]);
						}
						self.nodeToWww(conf.libs);
					}
				});
			});
		}
	}
}